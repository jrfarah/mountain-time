<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Time</title>
    
    <!-- Primary Meta Tags -->
    <meta name="title" content="Mountain Time">
    <meta name="description" content="Interactive mountain time-lapse viewer. Explore aligned images across time of day and seasons.">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://jrfarah.github.io/mountain-time/">
    <meta property="og:title" content="Mountain Time">
    <meta property="og:description" content="Interactive mountain time-lapse viewer. Explore aligned images across time of day and seasons.">
    <meta property="og:image" content="https://jrfarah.github.io/mountain-time/thumbnail.jpg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://jrfarah.github.io/mountain-time/">
    <meta property="twitter:title" content="Mountain Time">
    <meta property="twitter:description" content="Interactive mountain time-lapse viewer. Explore aligned images across time of day and seasons.">
    <meta property="twitter:image" content="https://jrfarah.github.io/mountain-time/thumbnail.jpg">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Playfair+Display:wght@400;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f8f6f4;
            color: #2c2c2c;
            overflow: hidden;
            height: 100vh;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            position: relative;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #imageCanvas {
            max-width: 100%;
            max-height: 100%;
            cursor: grab;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        #imageCanvas:active {
            cursor: grabbing;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 42, 42, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(139, 115, 85, 0.1);
            border-top: 3px solid #8b7355;
            border-radius: 50%;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #8b7355;
            font-size: 15px;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .progress-container {
            width: 300px;
            height: 8px;
            background: rgba(139, 115, 85, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8b7355, #a68968);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            color: #8b7355;
            font-size: 13px;
            margin-top: 12px;
            opacity: 0.8;
        }

        /* Intro Overlay */
        .intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        .intro-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .intro-content {
            max-width: 800px;
            padding: 40px;
            text-align: center;
        }

        .intro-sentence {
            font-family: 'Playfair Display', serif;
            font-size: 32px;
            line-height: 1.6;
            color: #e8e6e3;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1.2s ease, transform 1.2s ease;
        }

        .intro-sentence.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .skip-button {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 14px 32px;
            background: rgba(139, 115, 85, 0.15);
            color: #8b7355;
            border: 2px solid rgba(139, 115, 85, 0.3);
            border-radius: 30px;
            font-size: 15px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.4s ease;
            backdrop-filter: blur(10px);
        }

        .skip-button.visible {
            opacity: 1;
        }

        .skip-button:hover {
            background: rgba(139, 115, 85, 0.25);
            border-color: rgba(139, 115, 85, 0.5);
            transform: translateX(-50%) translateY(-4px);
            box-shadow: 0 10px 30px rgba(139, 115, 85, 0.2);
        }

        .loading-indicator {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .loading-indicator .spinner {
            width: 24px;
            height: 24px;
            border-width: 2px;
        }

        .loading-indicator .loading-text {
            font-size: 13px;
            opacity: 0.6;
        }

        .loading-indicator .progress-container {
            width: 250px;
            margin-top: 8px;
        }

        .loading-indicator .progress-text {
            font-size: 12px;
            margin-top: 8px;
        }

        @media (max-width: 768px) {
            .intro-sentence {
                font-size: 24px;
                line-height: 1.5;
            }

            .intro-content {
                padding: 20px;
            }
        }

        /* Side Control Panel */
        .control-panel {
            width: 420px;
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(20px);
            box-shadow: -2px 0 30px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            border-left: 1px solid rgba(139, 115, 85, 0.1);
            position: relative;
            background-size: cover;
            background-position: center;
            transition: background-image 0.6s ease-in-out;
        }

        .control-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: inherit;
            background-size: cover;
            background-position: center;
            opacity: 0.5;
            z-index: 0;
            transition: opacity 0.6s ease-in-out;
        }

        .control-panel > * {
            position: relative;
            z-index: 1;
        }

        .control-panel::-webkit-scrollbar {
            width: 6px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(139, 115, 85, 0.2);
            border-radius: 3px;
        }

        .control-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 115, 85, 0.3);
        }

        /* Header */
        .panel-header {
            padding: 40px 32px 32px;
            border-bottom: 1px solid rgba(139, 115, 85, 0.08);
        }

        .app-title {
            font-family: 'Playfair Display', serif;
            font-size: 28px;
            font-weight: 600;
            color: #2c2c2c;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }

        .app-subtitle {
            font-size: 13px;
            color: #8b7355;
            font-weight: 400;
            letter-spacing: 0.3px;
        }

        /* Content Sections */
        .panel-content {
            flex: 1;
            padding: 32px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: #8b7355;
            margin-bottom: 16px;
            opacity: 0.8;
        }

        /* Current Info Display */
        .current-info {
            background: linear-gradient(135deg, #f5f3f0 0%, #ebe8e4 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            border: 1px solid rgba(139, 115, 85, 0.08);
        }

        .current-datetime {
            font-family: 'Playfair Display', serif;
            font-size: 18px;
            font-weight: 600;
            color: #2c2c2c;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .current-meta {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .meta-item {
            font-size: 12px;
            color: #8b7355;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .meta-item::before {
            content: '';
            width: 4px;
            height: 4px;
            background: #8b7355;
            border-radius: 50%;
            opacity: 0.5;
        }

        /* Timeline Controls */
        .timeline-control {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 12px;
            border: 1px solid rgba(139, 115, 85, 0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .timeline-control:hover {
            box-shadow: 0 4px 12px rgba(139, 115, 85, 0.08);
        }

        .timeline-control.active {
            background: linear-gradient(135deg, #f5f3f0 0%, #ebe8e4 100%);
            border-color: #8b7355;
            box-shadow: 0 4px 16px rgba(139, 115, 85, 0.12);
        }

        .timeline-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 14px;
        }

        .timeline-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 500;
            color: #2c2c2c;
        }

        .timeline-icon {
            font-size: 16px;
        }

        .timeline-value {
            font-size: 12px;
            color: #8b7355;
            font-weight: 500;
        }

        .timeline-slider {
            position: relative;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(139, 115, 85, 0.1);
            outline: none;
            -webkit-appearance: none;
            transition: background 0.2s;
        }

        input[type="range"]:hover {
            background: rgba(139, 115, 85, 0.15);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #8b7355;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(139, 115, 85, 0.3);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 3px 12px rgba(139, 115, 85, 0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #8b7355;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(139, 115, 85, 0.3);
        }

        .timeline-range {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 10px;
            color: rgba(139, 115, 85, 0.6);
            font-weight: 400;
        }

        /* Button Groups */
        .button-group {
            display: grid;
            gap: 8px;
        }

        .button-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        button {
            padding: 12px 16px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid rgba(139, 115, 85, 0.15);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            background: white;
            color: #2c2c2c;
            font-family: 'Inter', sans-serif;
        }

        button:hover {
            background: #8b7355;
            color: white;
            border-color: #8b7355;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 115, 85, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        button.primary {
            background: #8b7355;
            color: white;
            border-color: #8b7355;
        }

        button.primary:hover {
            background: #755f47;
            border-color: #755f47;
        }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: white;
            border-radius: 12px;
            border: 1px solid rgba(139, 115, 85, 0.08);
            transition: all 0.2s;
        }

        .toggle-container:hover {
            background: #fafaf9;
        }

        .toggle-label {
            font-size: 13px;
            font-weight: 500;
            color: #2c2c2c;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(139, 115, 85, 0.2);
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        input:checked + .toggle-slider {
            background-color: #8b7355;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .stat-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(139, 115, 85, 0.08);
            transition: all 0.2s;
        }

        .stat-card:hover {
            background: #fafaf9;
        }

        .stat-label {
            font-size: 11px;
            color: rgba(139, 115, 85, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #2c2c2c;
        }

        /* Zoom Controls */
        .zoom-control {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            background: white;
            border-radius: 12px;
            border: 1px solid rgba(139, 115, 85, 0.08);
        }

        .zoom-buttons {
            display: flex;
            gap: 6px;
            flex: 1;
        }

        .zoom-buttons button {
            padding: 10px 14px;
            font-size: 16px;
        }

        .zoom-display {
            font-size: 13px;
            font-weight: 600;
            color: #8b7355;
            min-width: 50px;
            text-align: right;
        }

        /* Footer */
        .panel-footer {
            padding: 24px 32px;
            border-top: 1px solid rgba(139, 115, 85, 0.08);
            text-align: center;
        }

        .footer-text {
            font-size: 11px;
            color: rgba(139, 115, 85, 0.6);
            line-height: 1.6;
        }

        .keyboard-hint {
            margin-top: 12px;
            font-size: 10px;
            color: rgba(139, 115, 85, 0.5);
            font-style: italic;
        }

        /* Floating Toggle Button (Mobile) */
        .panel-toggle {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 115, 85, 0.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            z-index: 100;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }

        .panel-toggle:hover {
            background: white;
            transform: scale(1.05);
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .control-panel {
                width: 360px;
            }
            
            .panel-content {
                padding: 24px;
            }
        }

        @media (max-width: 768px) {
            .control-panel {
                position: fixed;
                top: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                max-width: 400px;
                transform: translateX(100%);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 50;
            }

            .control-panel.open {
                transform: translateX(0);
            }

            .panel-toggle {
                display: flex;
            }

            .canvas-area {
                width: 100vw;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <!-- Intro Overlay -->
    <div id="introOverlay" class="intro-overlay">
        <div class="intro-content">
            <p class="intro-sentence" id="sentence1">Every day, I walk my dog by the same mountain.</p>
            <p class="intro-sentence" id="sentence2">And every day, I take a picture.</p>
            <p class="intro-sentence" id="sentence3">Here is the mountain from my perspective over the last 3 years.</p>
        </div>
        
        <div class="loading-indicator" id="loadingIndicator">
            <div class="spinner"></div>
            <p class="loading-text">Loading images...</p>
            <div class="progress-container">
                <div id="introProgressBar" class="progress-bar"></div>
            </div>
            <p id="introProgressText" class="progress-text">0 / 0</p>
        </div>
        
        <button id="skipButton" class="skip-button">Enter ‚Üí</button>
    </div>

    <div class="app-container">
        <!-- Canvas Area -->
        <div class="canvas-area">
            <canvas id="imageCanvas"></canvas>
            <div id="loadingOverlay" class="loading-overlay">
                <div class="spinner"></div>
                <p class="loading-text">Loading images...</p>
                <div class="progress-container">
                    <div id="progressBar" class="progress-bar"></div>
                </div>
                <p id="progressText" class="progress-text">0 / 0</p>
            </div>
        </div>

        <!-- Mobile Toggle Button -->
        <div class="panel-toggle" id="panelToggle">‚ò∞</div>

        <!-- Control Panel -->
        <div class="control-panel" id="controlPanel">
            <div class="panel-header">
                <h1 class="app-title">Mountain Time</h1>
                <p class="app-subtitle">Peak alignment viewer</p>
            </div>

            <div class="panel-content">
                <!-- Current Info -->
                <div class="current-info">
                    <div class="current-datetime" id="currentDateTime">Loading...</div>
                    <div class="current-meta">
                        <span class="meta-item" id="imageCounter">‚Äî / ‚Äî</span>
                        <span class="meta-item" id="activeView">Chronological</span>
                    </div>
                </div>

                <!-- Timeline Scrubbers -->
                <div class="section">
                    <div class="section-title">Timeline Views</div>
                    
                    <!-- Chronological -->
                    <div class="timeline-control active" id="chronologicalContainer">
                        <div class="timeline-header">
                            <div class="timeline-label">
                                <span class="timeline-icon">üìÖ</span>
                                <span>Chronological</span>
                            </div>
                            <div class="timeline-value" id="chronoValue">‚Äî</div>
                        </div>
                        <div class="timeline-slider">
                            <input type="range" id="imageSlider" min="0" max="0" value="0" step="1">
                            <div class="timeline-range">
                                <span id="startDate">‚Äî</span>
                                <span id="endDate">‚Äî</span>
                            </div>
                        </div>
                    </div>

                    <!-- Time of Day -->
                    <div class="timeline-control" id="timeOfDayContainer">
                        <div class="timeline-header">
                            <div class="timeline-label">
                                <span class="timeline-icon">üåÖ</span>
                                <span>Time of Day</span>
                            </div>
                            <div class="timeline-value" id="todValue">‚Äî</div>
                        </div>
                        <div class="timeline-slider">
                            <input type="range" id="timeOfDaySlider" min="0" max="0" value="0" step="1">
                            <div class="timeline-range">
                                <span id="startTimeOfDay">‚Äî</span>
                                <span id="endTimeOfDay">‚Äî</span>
                            </div>
                        </div>
                    </div>

                    <!-- Time of Year -->
                    <div class="timeline-control" id="timeOfYearContainer">
                        <div class="timeline-header">
                            <div class="timeline-label">
                                <span class="timeline-icon">üçÇ</span>
                                <span>Time of Year</span>
                            </div>
                            <div class="timeline-value" id="toyValue">‚Äî</div>
                        </div>
                        <div class="timeline-slider">
                            <input type="range" id="timeOfYearSlider" min="0" max="0" value="0" step="1">
                            <div class="timeline-range">
                                <span id="startTimeOfYear">‚Äî</span>
                                <span id="endTimeOfYear">‚Äî</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Playback Controls -->
                <div class="section">
                    <div class="section-title">Playback</div>
                    <div class="button-group">
                        <div class="button-row">
                            <button id="prevBtn">‚Üê Prev</button>
                            <button id="playBtn" class="primary">‚ñ∂ Play</button>
                            <button id="nextBtn">Next ‚Üí</button>
                        </div>
                    </div>
                </div>

                <!-- Zoom Controls -->
                <div class="section">
                    <div class="section-title">View Controls</div>
                    <div class="zoom-control">
                        <div class="zoom-buttons">
                            <button id="zoomOutBtn">‚àí</button>
                            <button id="resetZoomBtn">Reset</button>
                            <button id="zoomInBtn">+</button>
                        </div>
                        <div class="zoom-display" id="zoomInfo">100%</div>
                    </div>
                </div>

                <!-- Display Options -->
                <div class="section">
                    <div class="section-title">Display</div>
                    <div class="toggle-container">
                        <span class="toggle-label">Show Alignment Peaks</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="showPeaksCheckbox">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>




                <!-- Statistics -->
                <div class="section">
                    <div class="section-title">Collection Stats</div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Total Images</div>
                            <div class="stat-value" id="totalImages">‚Äî</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Date Range</div>
                            <div class="stat-value" id="dateRange">‚Äî</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-footer">
                <p class="footer-text">
                    Images aligned using peak-based similarity transformation
                </p>
                <p class="keyboard-hint">
                    ‚Üê ‚Üí arrows ‚Ä¢ space ‚Ä¢ +/‚àí ‚Ä¢ 0 to reset
                </p>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const DATABASE_URL = 'peaks_database.json';
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 900;

        // State
        let database = [];
        let databaseChronological = [];
        let databaseTimeOfDay = [];
        let databaseTimeOfYear = [];
        let currentMode = 'chronological';
        let currentIndex = 0;
        let isPlaying = false;
        let playInterval = null;
        let loadedImages = [];
        let referencePeaks = null;
        let showPeaks = false;
        let showPanelBackground = false;
        
        // Zoom and pan state
        let zoomLevel = 0.35; // Start at 35% zoom to see full panorama
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;

        // Composite image for performance (large bounding box of all images)
        let compositeCanvas = null;
        let compositeCtx = null;
        let compositeReady = false;
        let compositeOffsetX = 0;
        let compositeOffsetY = 0;

        // Throttle for panel background updates
        let lastBackgroundUpdate = 0;
        let backgroundUpdateThrottle = 200; // Update every 200ms max (less frequent for better performance)
        
        // Cache for processed images with fade to avoid recomputing
        const processedImageCache = new Map();

        // DOM elements
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('imageSlider');
        const timeOfDaySlider = document.getElementById('timeOfDaySlider');
        const timeOfYearSlider = document.getElementById('timeOfYearSlider');
        const playBtn = document.getElementById('playBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const zoomInfo = document.getElementById('zoomInfo');
        const currentDateTimeEl = document.getElementById('currentDateTime');
        const chronoValueEl = document.getElementById('chronoValue');
        const todValueEl = document.getElementById('todValue');
        const toyValueEl = document.getElementById('toyValue');
        const startDateEl = document.getElementById('startDate');
        const endDateEl = document.getElementById('endDate');
        const startTimeOfDayEl = document.getElementById('startTimeOfDay');
        const endTimeOfDayEl = document.getElementById('endTimeOfDay');
        const startTimeOfYearEl = document.getElementById('startTimeOfYear');
        const endTimeOfYearEl = document.getElementById('endTimeOfYear');
        const imageCounterEl = document.getElementById('imageCounter');
        const totalImagesEl = document.getElementById('totalImages');
        const dateRangeEl = document.getElementById('dateRange');
        const activeViewEl = document.getElementById('activeView');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const showPeaksCheckbox = document.getElementById('showPeaksCheckbox');
        const chronologicalContainer = document.getElementById('chronologicalContainer');
        const timeOfDayContainer = document.getElementById('timeOfDayContainer');
        const timeOfYearContainer = document.getElementById('timeOfYearContainer');
        const panelToggle = document.getElementById('panelToggle');
        const controlPanel = document.getElementById('controlPanel');

        // Set canvas size
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Mobile panel toggle
        panelToggle.addEventListener('click', () => {
            controlPanel.classList.toggle('open');
        });

        // Utility functions
        function formatDate(isoString) {
            if (!isoString) return 'Unknown';
            const date = new Date(isoString);
            return date.toLocaleDateString('en-US', { 
                weekday: 'short',
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function formatDateShort(isoString) {
            if (!isoString) return 'Unknown';
            const date = new Date(isoString);
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: 'numeric'
            });
        }

        function formatTimeOfDay(isoString) {
            if (!isoString) return 'Unknown';
            const date = new Date(isoString);
            return date.toLocaleTimeString('en-US', { 
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function formatTimeOfYear(isoString) {
            if (!isoString) return 'Unknown';
            const date = new Date(isoString);
            return date.toLocaleDateString('en-US', { 
                month: 'long',
                day: 'numeric'
            });
        }

        function getTimeOfDayMinutes(isoString) {
            const date = new Date(isoString);
            return date.getHours() * 60 + date.getMinutes();
        }

        function getTimeOfYearDays(isoString) {
            const date = new Date(isoString);
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay);
        }

        function getCurrentDatabase() {
            if (currentMode === 'timeOfDay') return databaseTimeOfDay;
            if (currentMode === 'timeOfYear') return databaseTimeOfYear;
            return databaseChronological;
        }

        function getCurrentEntry() {
            return getCurrentDatabase()[currentIndex];
        }

        function setActiveMode(mode) {
            currentMode = mode;
            chronologicalContainer.classList.remove('active');
            timeOfDayContainer.classList.remove('active');
            timeOfYearContainer.classList.remove('active');
            
            if (mode === 'chronological') {
                chronologicalContainer.classList.add('active');
                activeViewEl.textContent = 'Chronological';
            } else if (mode === 'timeOfDay') {
                timeOfDayContainer.classList.add('active');
                activeViewEl.textContent = 'Time of Day';
            } else if (mode === 'timeOfYear') {
                timeOfYearContainer.classList.add('active');
                activeViewEl.textContent = 'Time of Year';
            }
        }

        // Similarity transformation functions
        function computeSimilarityTransformation(srcPoints, dstPoints) {
            const src = srcPoints.map(p => ({x: p[0], y: p[1]}));
            const dst = dstPoints.map(p => ({x: p[0], y: p[1]}));

            const srcCenter = {
                x: (src[0].x + src[1].x) / 2,
                y: (src[0].y + src[1].y) / 2
            };
            const dstCenter = {
                x: (dst[0].x + dst[1].x) / 2,
                y: (dst[0].y + dst[1].y) / 2
            };

            const srcCentered = src.map(p => ({
                x: p.x - srcCenter.x,
                y: p.y - srcCenter.y
            }));
            const dstCentered = dst.map(p => ({
                x: p.x - dstCenter.x,
                y: p.y - dstCenter.y
            }));

            const srcDist = Math.sqrt(
                Math.pow(srcCentered[1].x - srcCentered[0].x, 2) +
                Math.pow(srcCentered[1].y - srcCentered[0].y, 2)
            );
            const dstDist = Math.sqrt(
                Math.pow(dstCentered[1].x - dstCentered[0].x, 2) +
                Math.pow(dstCentered[1].y - dstCentered[0].y, 2)
            );

            const scale = srcDist < 1e-10 ? 1.0 : dstDist / srcDist;

            const srcAngle = Math.atan2(
                srcCentered[1].y - srcCentered[0].y,
                srcCentered[1].x - srcCentered[0].x
            );
            const dstAngle = Math.atan2(
                dstCentered[1].y - dstCentered[0].y,
                dstCentered[1].x - dstCentered[0].x
            );
            const angle = dstAngle - srcAngle;

            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);

            const srcCenterTransformed = {
                x: scale * (cosA * srcCenter.x - sinA * srcCenter.y),
                y: scale * (sinA * srcCenter.x + cosA * srcCenter.y)
            };

            const translation = {
                x: dstCenter.x - srcCenterTransformed.x,
                y: dstCenter.y - srcCenterTransformed.y
            };

            return { scale, angle, tx: translation.x, ty: translation.y };
        }

        // Create composite image with all images stacked (run once after loading)
        function createCompositeImage() {
            console.log('Creating large composite image with all stacked images...');
            
            // First pass: calculate bounding box of all transformed images
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            const transforms = [];
            
            for (let i = 0; i < database.length; i++) {
                const entry = database[i];
                const img = loadedImages[i];
                
                if (!img || !img.complete) continue;
                
                const srcPeaks = [
                    [entry.higher_peak.x, entry.higher_peak.y],
                    [entry.lower_peak.x, entry.lower_peak.y]
                ];

                const transform = computeSimilarityTransformation(srcPeaks, referencePeaks);
                transforms.push({ transform, img, entry });
                
                // Calculate corners of transformed image
                const corners = [
                    { x: 0, y: 0 },
                    { x: img.width, y: 0 },
                    { x: img.width, y: img.height },
                    { x: 0, y: img.height }
                ];
                
                // Transform each corner
                for (const corner of corners) {
                    const cos_a = Math.cos(transform.angle);
                    const sin_a = Math.sin(transform.angle);
                    
                    const transformedX = transform.scale * (cos_a * corner.x - sin_a * corner.y) + transform.tx;
                    const transformedY = transform.scale * (sin_a * corner.x + cos_a * corner.y) + transform.ty;
                    
                    minX = Math.min(minX, transformedX);
                    minY = Math.min(minY, transformedY);
                    maxX = Math.max(maxX, transformedX);
                    maxY = Math.max(maxY, transformedY);
                }
            }
            
            // Add padding
            const padding = 100;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;
            
            const compositeWidth = Math.ceil(maxX - minX);
            const compositeHeight = Math.ceil(maxY - minY);
            
            console.log(`Composite size: ${compositeWidth}x${compositeHeight} (bounding box of all images)`);
            console.log(`Offset: (${minX}, ${minY})`);
            
            // Store offset for drawing
            compositeOffsetX = minX;
            compositeOffsetY = minY;
            
            // Create large offscreen canvas
            compositeCanvas = document.createElement('canvas');
            compositeCanvas.width = compositeWidth;
            compositeCanvas.height = compositeHeight;
            compositeCtx = compositeCanvas.getContext('2d');
            
            // Dark background
            compositeCtx.fillStyle = '#2a2a2a';
            compositeCtx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
            
            // Draw all images at low opacity, adjusted for offset
            compositeCtx.globalAlpha = 0.03;
            
            for (const { transform, img } of transforms) {
                compositeCtx.save();
                // Translate to account for bounding box offset
                compositeCtx.translate(-minX, -minY);
                compositeCtx.translate(transform.tx, transform.ty);
                compositeCtx.rotate(transform.angle);
                compositeCtx.scale(transform.scale, transform.scale);
                compositeCtx.drawImage(img, 0, 0);
                compositeCtx.restore();
            }
            
            compositeCtx.globalAlpha = 1.0;
            compositeReady = true;
            
            console.log('Composite image ready!');
            console.log(`Individual image size: ~${database[0] ? loadedImages[0]?.width : '?'}x${database[0] ? loadedImages[0]?.height : '?'}`);
            console.log(`Composite is ${Math.round(compositeWidth / (loadedImages[0]?.width || 1) * 100) / 100}x larger in width`);
            console.log(`You can now pan/zoom to explore the full panorama!`);
        }

        // Function to download the composite image
        function downloadComposite() {
            if (!compositeCanvas) {
                alert('Composite image not ready yet!');
                return;
            }
            
            try {
                compositeCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = 'mountain_time_composite.png';
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                });
            } catch (e) {
                alert('Error downloading composite: ' + e.message);
            }
        }

        // Update control panel background with current image (throttled)
        function updatePanelBackground(img, force = false) {
            // Skip if disabled
            if (!showPanelBackground) {
                controlPanel.style.backgroundImage = 'none';
                return;
            }
            
            const now = Date.now();
            
            // Throttle updates unless forced
            if (!force && (now - lastBackgroundUpdate) < backgroundUpdateThrottle) {
                return;
            }
            
            lastBackgroundUpdate = now;
            
            // Create a smaller, lower quality version for better performance
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 600;  // Reduced from 800
            tempCanvas.height = 450; // Reduced from 600
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw scaled image
            tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // Apply blur using canvas filter (this actually works!)
            tempCtx.filter = 'blur(80px) brightness(1.5) saturate(1.2)';  // Slightly less blur for performance
            tempCtx.drawImage(tempCanvas, 0, 0);
            
            try {
                const dataUrl = tempCanvas.toDataURL('image/jpeg', 0.5);  // Lower quality (0.5 instead of 0.7)
                controlPanel.style.backgroundImage = `url(${dataUrl})`;
            } catch (e) {
                console.warn('Could not set panel background:', e);
            }
        }

        // Create an image with edge fade effect - called once per image and cached
        function createImageWithEdgeFade(img) {
            const imgWidth = img.width;
            const imgHeight = img.height;
            
            // Calculate fade distance (10% from edges)
            const fadeDistanceX = imgWidth * 0.025;
            const fadeDistanceY = imgHeight * 0.025;

            // Create a blurred version of the image
            const maxBlurPx = 40;
            const blurCanvas = document.createElement('canvas');
            blurCanvas.width = imgWidth;
            blurCanvas.height = imgHeight;
            const blurCtx = blurCanvas.getContext('2d');
            blurCtx.filter = `blur(${maxBlurPx}px)`;
            blurCtx.drawImage(img, 0, 0);
            blurCtx.filter = 'none';

            // Create the mask canvas for alpha and blur blend
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = imgWidth;
            maskCanvas.height = imgHeight;
            const maskCtx = maskCanvas.getContext('2d');

            // Alpha + blur blend mask, per-pixel
            const imageData = maskCtx.createImageData(imgWidth, imgHeight);
            const data = imageData.data;

            // Pre-compute edge distances for performance
            for (let y = 0; y < imgHeight; y++) {
                for (let x = 0; x < imgWidth; x++) {
                    const idx = (y * imgWidth + x) * 4;
                    
                    // Distances from edges
                    const minDistX = Math.min(x, imgWidth - x);
                    const minDistY = Math.min(y, imgHeight - y);
                    
                    // Fade/Blur factors (1.0 at center, 0 at edge)
                    const factorX = Math.max(0, Math.min(1, minDistX / fadeDistanceX));
                    const factorY = Math.max(0, Math.min(1, minDistY / fadeDistanceY));
                    const minFactor = Math.min(factorX, factorY);

                    // Store blur amount and alpha
                    data[idx] = Math.round((1 - minFactor) * 255);  // R: blur amount
                    data[idx + 1] = 0;  // G
                    data[idx + 2] = 0;  // B
                    data[idx + 3] = Math.round(minFactor * 255);  // A: alpha
                }
            }
            maskCtx.putImageData(imageData, 0, 0);

            // Compose the final image
            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = imgWidth;
            resultCanvas.height = imgHeight;
            const resultCtx = resultCanvas.getContext('2d');
            
            // Get pixel data from both images
            const sharpCtx = document.createElement('canvas').getContext('2d');
            sharpCtx.canvas.width = imgWidth;
            sharpCtx.canvas.height = imgHeight;
            sharpCtx.drawImage(img, 0, 0);
            const sharpData = sharpCtx.getImageData(0, 0, imgWidth, imgHeight).data;
            const blurData = blurCtx.getImageData(0, 0, imgWidth, imgHeight).data;

            // Blend based on mask
            const outImage = resultCtx.createImageData(imgWidth, imgHeight);
            const outData = outImage.data;
            const maskAlphaData = maskCtx.getImageData(0, 0, imgWidth, imgHeight).data;

            const totalPixels = imgWidth * imgHeight;
            for (let i = 0; i < totalPixels; i++) {
                const baseIdx = i * 4;
                const blurAmount = maskAlphaData[baseIdx] / 255;
                const alpha = maskAlphaData[baseIdx + 3] / 255;
                const sharpAmount = 1 - blurAmount;

                // Blend sharp and blurred
                outData[baseIdx] = sharpData[baseIdx] * sharpAmount + blurData[baseIdx] * blurAmount;
                outData[baseIdx + 1] = sharpData[baseIdx + 1] * sharpAmount + blurData[baseIdx + 1] * blurAmount;
                outData[baseIdx + 2] = sharpData[baseIdx + 2] * sharpAmount + blurData[baseIdx + 2] * blurAmount;
                outData[baseIdx + 3] = alpha * 255;
            }
            resultCtx.putImageData(outImage, 0, 0);
            
            return resultCanvas;
        }

        // Draw aligned image on canvas - simple and clean with soft edge fade
        function drawAlignedImage(index) {
            const db = getCurrentDatabase();
            if (index < 0 || index >= db.length) return;

            const currentEntry = db[index];
            const currentImgIndex = database.findIndex(e => e.filepath === currentEntry.filepath);
            const currentImg = loadedImages[currentImgIndex];

            if (!currentImg || !currentImg.complete) {
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#8b7355';
                ctx.font = '16px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('Loading image...', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Clear canvas
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update control panel background with current image
            updatePanelBackground(currentImg);

            // Draw the composite background with zoom/pan, blur, and brightness
            if (compositeReady && compositeCanvas) {
                ctx.save();
                
                // Apply blur and brighten to background
                ctx.filter = 'blur(11px) brightness(1.1)';
                
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(zoomLevel, zoomLevel);
                ctx.translate(-canvas.width / 2 + panX, -canvas.height / 2 + panY);
                ctx.translate(compositeOffsetX, compositeOffsetY);
                ctx.drawImage(compositeCanvas, 0, 0);
                
                // Reset filter
                ctx.filter = 'none';
                ctx.restore();
            }

            // Draw current image with soft edge fade
            const srcPeaks = [
                [currentEntry.higher_peak.x, currentEntry.higher_peak.y],
                [currentEntry.lower_peak.x, currentEntry.lower_peak.y]
            ];

            const transform = computeSimilarityTransformation(srcPeaks, referencePeaks);

            const imgWidth = currentImg.width;
            const imgHeight = currentImg.height;
            
            // Check cache for processed image with fade
            const cacheKey = currentEntry.filepath;
            let processedImage = processedImageCache.get(cacheKey);
            
            if (!processedImage) {
                // Process image with edge fade only once and cache it
                processedImage = createImageWithEdgeFade(currentImg);
                processedImageCache.set(cacheKey, processedImage);
            }

            // Draw the processed image with transform
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-canvas.width / 2 + panX, -canvas.height / 2 + panY);
            ctx.translate(transform.tx, transform.ty);
            ctx.rotate(transform.angle);
            ctx.scale(transform.scale, transform.scale);
            ctx.drawImage(processedImage, 0, 0);
            ctx.restore();


            // Draw peak markers
            if (showPeaks) {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(zoomLevel, zoomLevel);
                ctx.translate(-canvas.width / 2 + panX, -canvas.height / 2 + panY);
                
                const radius = 6;
                
                // Higher peak
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.arc(referencePeaks[0][0], referencePeaks[0][1], radius, 0, 2 * Math.PI);
                ctx.stroke();

                // Lower peak
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.arc(referencePeaks[1][0], referencePeaks[1][1], radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                ctx.restore();
            }

            updateUI();
        }

        function updateUI() {
            const entry = getCurrentEntry();
            const db = getCurrentDatabase();
            
            currentDateTimeEl.textContent = formatDate(entry.datetime);
            chronoValueEl.textContent = formatDateShort(entry.datetime);
            todValueEl.textContent = formatTimeOfDay(entry.datetime);
            toyValueEl.textContent = formatTimeOfYear(entry.datetime);
            
            imageCounterEl.textContent = `${currentIndex + 1} of ${db.length}`;
            
            updateSliderPositions();
            
            zoomInfo.textContent = `${Math.round(zoomLevel * 100)}%`;
        }

        function updateSliderPositions() {
            const entry = getCurrentEntry();
            
            const chronoIdx = databaseChronological.findIndex(e => e.filepath === entry.filepath);
            const todIdx = databaseTimeOfDay.findIndex(e => e.filepath === entry.filepath);
            const toyIdx = databaseTimeOfYear.findIndex(e => e.filepath === entry.filepath);
            
            slider.value = chronoIdx;
            timeOfDaySlider.value = todIdx;
            timeOfYearSlider.value = toyIdx;
        }

        function switchToImage(filepath, newMode) {
            const db = getCurrentDatabase();
            const newIndex = db.findIndex(e => e.filepath === filepath);
            if (newIndex !== -1) {
                currentIndex = newIndex;
                if (newMode) setActiveMode(newMode);
                drawAlignedImage(currentIndex);
            }
        }

        function nextImage() {
            const db = getCurrentDatabase();
            if (currentIndex < db.length - 1) {
                currentIndex++;
                drawAlignedImage(currentIndex);
            } else if (isPlaying) {
                stopPlayback();
            }
        }

        function prevImage() {
            if (currentIndex > 0) {
                currentIndex--;
                drawAlignedImage(currentIndex);
            }
        }

        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.3, 5.0);
            drawAlignedImage(currentIndex);
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.3, 0.1); // Allow zoom out to 10%
            drawAlignedImage(currentIndex);
        }

        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            drawAlignedImage(currentIndex);
        }

        function startPlayback() {
            if (isPlaying) return;
            isPlaying = true;
            playBtn.textContent = '‚è∏ Pause';
            playBtn.classList.remove('primary');
            playInterval = setInterval(() => {
                nextImage();
            }, 500);
        }

        function stopPlayback() {
            if (!isPlaying) return;
            isPlaying = false;
            playBtn.textContent = '‚ñ∂ Play';
            playBtn.classList.add('primary');
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }

        function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        // Event listeners
        slider.addEventListener('input', (e) => {
            stopPlayback();
            const filepath = databaseChronological[parseInt(e.target.value)].filepath;
            switchToImage(filepath, 'chronological');
        });

        timeOfDaySlider.addEventListener('input', (e) => {
            stopPlayback();
            const filepath = databaseTimeOfDay[parseInt(e.target.value)].filepath;
            switchToImage(filepath, 'timeOfDay');
        });

        timeOfYearSlider.addEventListener('input', (e) => {
            stopPlayback();
            const filepath = databaseTimeOfYear[parseInt(e.target.value)].filepath;
            switchToImage(filepath, 'timeOfYear');
        });

        playBtn.addEventListener('click', togglePlayback);
        prevBtn.addEventListener('click', () => {
            stopPlayback();
            prevImage();
        });
        nextBtn.addEventListener('click', () => {
            stopPlayback();
            nextImage();
        });

        zoomInBtn.addEventListener('click', zoomIn);
        zoomOutBtn.addEventListener('click', zoomOut);
        resetZoomBtn.addEventListener('click', resetZoom);

        showPeaksCheckbox.addEventListener('change', (e) => {
            showPeaks = e.target.checked;
            drawAlignedImage(currentIndex);
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        });

        // Pan with mouse drag
        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            lastPanX = panX;
            lastPanY = panY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            
            const dx = e.clientX - panStartX;
            const dy = e.clientY - panStartY;
            
            panX = lastPanX + dx / zoomLevel;
            panY = lastPanY + dy / zoomLevel;
            
            drawAlignedImage(currentIndex);
        });

        canvas.addEventListener('mouseup', () => {
            isPanning = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isPanning = false;
            canvas.style.cursor = 'grab';
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                stopPlayback();
                prevImage();
            } else if (e.key === 'ArrowRight') {
                stopPlayback();
                nextImage();
            } else if (e.key === ' ') {
                e.preventDefault();
                togglePlayback();
            } else if (e.key === '+' || e.key === '=') {
                e.preventDefault();
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                zoomOut();
            } else if (e.key === '0') {
                e.preventDefault();
                resetZoom();
            }
        });

        // Touch support
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isPanning = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastPanX = panX;
                lastPanY = panY;
                e.preventDefault();
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (isPanning && e.touches.length === 1) {
                const dx = e.touches[0].clientX - touchStartX;
                const dy = e.touches[0].clientY - touchStartY;
                
                panX = lastPanX + dx / zoomLevel;
                panY = lastPanY + dy / zoomLevel;
                
                drawAlignedImage(currentIndex);
                e.preventDefault();
            }
        });

        canvas.addEventListener('touchend', () => {
            isPanning = false;
        });

        // Load database and images
        async function initialize() {
            try {
                const response = await fetch(DATABASE_URL);
                database = await response.json();

                if (database.length === 0) {
                    throw new Error('No images in database');
                }

                databaseChronological = [...database].sort((a, b) => {
                    return new Date(a.datetime) - new Date(b.datetime);
                });

                databaseTimeOfDay = [...database].sort((a, b) => {
                    return getTimeOfDayMinutes(a.datetime) - getTimeOfDayMinutes(b.datetime);
                });

                databaseTimeOfYear = [...database].sort((a, b) => {
                    return getTimeOfYearDays(a.datetime) - getTimeOfYearDays(b.datetime);
                });

                const referenceEntry = databaseChronological[0];
                referencePeaks = [
                    [referenceEntry.higher_peak.x, referenceEntry.higher_peak.y],
                    [referenceEntry.lower_peak.x, referenceEntry.lower_peak.y]
                ];

                const numImages = database.length;
                
                slider.max = numImages - 1;
                timeOfDaySlider.max = numImages - 1;
                timeOfYearSlider.max = numImages - 1;
                
                totalImagesEl.textContent = numImages;
                
                startDateEl.textContent = formatDateShort(databaseChronological[0].datetime);
                endDateEl.textContent = formatDateShort(databaseChronological[numImages - 1].datetime);
                
                startTimeOfDayEl.textContent = formatTimeOfDay(databaseTimeOfDay[0].datetime);
                endTimeOfDayEl.textContent = formatTimeOfDay(databaseTimeOfDay[numImages - 1].datetime);
                
                startTimeOfYearEl.textContent = formatTimeOfYear(databaseTimeOfYear[0].datetime);
                endTimeOfYearEl.textContent = formatTimeOfYear(databaseTimeOfYear[numImages - 1].datetime);
                
                const firstDate = new Date(databaseChronological[0].datetime);
                const lastDate = new Date(databaseChronological[numImages - 1].datetime);
                const daysDiff = Math.round((lastDate - firstDate) / (1000 * 60 * 60 * 24));
                dateRangeEl.textContent = `${daysDiff} days`;

                // Initialize progress tracking
                let loadedCount = 0;
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                const introProgressBar = document.getElementById('introProgressBar');
                const introProgressText = document.getElementById('introProgressText');
                
                const updateProgress = () => {
                    const percent = Math.round((loadedCount / numImages) * 100);
                    progressBar.style.width = `${percent}%`;
                    progressText.textContent = `${loadedCount} / ${numImages}`;
                    introProgressBar.style.width = `${percent}%`;
                    introProgressText.textContent = `${loadedCount} / ${numImages}`;
                };
                
                updateProgress();

                const imagePromises = database.map((entry, index) => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            loadedImages[index] = img;
                            loadedCount++;
                            updateProgress();
                            resolve();
                        };
                        img.onerror = () => {
                            console.error(`Failed to load: ${entry.filepath}`);
                            loadedCount++;
                            updateProgress();
                            resolve();
                        };
                        img.src = entry.filepath;
                    });
                });

                await Promise.all(imagePromises);

                // Update loading text to show preprocessing
                const loadingTextEl = document.querySelector('#loadingIndicator .loading-text');
                loadingTextEl.textContent = 'Processing images...';
                progressText.textContent = 'Preparing for smooth playback';
                introProgressText.textContent = 'Preparing for smooth playback';

                // Preprocess all images with edge fade for smooth playback
                console.log('Preprocessing images with edge fade...');
                let processedCount = 0;
                
                for (let i = 0; i < database.length; i++) {
                    const entry = database[i];
                    const img = loadedImages[i];
                    
                    if (img && img.complete) {
                        const cacheKey = entry.filepath;
                        if (!processedImageCache.has(cacheKey)) {
                            // Process the image and cache it
                            const processedImage = createImageWithEdgeFade(img);
                            processedImageCache.set(cacheKey, processedImage);
                        }
                    }
                    
                    processedCount++;
                    const percent = Math.round((processedCount / numImages) * 100);
                    progressBar.style.width = `${percent}%`;
                    progressText.textContent = `${processedCount} / ${numImages}`;
                    introProgressBar.style.width = `${percent}%`;
                    introProgressText.textContent = `${processedCount} / ${numImages}`;
                    
                    // Allow UI to update every 5 images
                    if (processedCount % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                console.log('All images preprocessed!');

                // Create the composite image with all stacked images
                console.log('Creating composite...');
                createCompositeImage();

                loadingOverlay.classList.add('hidden');
                
                // Show skip button on intro overlay
                imagesLoaded = true;
                showSkipButton();

                setActiveMode('chronological');
                currentIndex = 0;
                
                // Set default zoom to 35% and center on alignment points
                zoomLevel = 0.35;
                
                // Calculate pan offset to center the reference peaks
                // Reference peaks are already at a specific position, we want them centered in the canvas
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const peakCenterX = (referencePeaks[0][0] + referencePeaks[1][0]) / 2;
                const peakCenterY = (referencePeaks[0][1] + referencePeaks[1][1]) / 2;
                
                panX = centerX - peakCenterX;
                panY = centerY - peakCenterY;
                
                drawAlignedImage(0);

                console.log(`Loaded ${database.length} images successfully!`);
            } catch (error) {
                console.error('Error initializing:', error);
                loadingOverlay.innerHTML = `
                    <div class="spinner"></div>
                    <p class="loading-text" style="color: #d97706;">Error: ${error.message}</p>
                `;
            }
        }

        // Intro animation
        let imagesLoaded = false;
        
        function startIntroAnimation() {
            const sentence1 = document.getElementById('sentence1');
            const sentence2 = document.getElementById('sentence2');
            const sentence3 = document.getElementById('sentence3');
            
            // Fade in sentences one at a time
            setTimeout(() => {
                sentence1.classList.add('visible');
            }, 500);
            
            setTimeout(() => {
                sentence2.classList.add('visible');
            }, 2800);
            
            setTimeout(() => {
                sentence3.classList.add('visible');
            }, 5100);
        }
        
        function showSkipButton() {
            const skipButton = document.getElementById('skipButton');
            const loadingIndicator = document.getElementById('loadingIndicator');
            
            // Hide loading indicator
            loadingIndicator.style.opacity = '0';
            setTimeout(() => {
                loadingIndicator.style.display = 'none';
            }, 400);
            
            // Show skip button
            setTimeout(() => {
                skipButton.classList.add('visible');
            }, 500);
        }
        
        function hideIntro() {
            const introOverlay = document.getElementById('introOverlay');
            introOverlay.classList.add('hidden');
        }
        
        // Skip button handler
        document.getElementById('skipButton').addEventListener('click', hideIntro);
        
        // Start intro animation immediately
        startIntroAnimation();
        
        // Start initialization
        initialize();
    </script>
</body>
</html>
